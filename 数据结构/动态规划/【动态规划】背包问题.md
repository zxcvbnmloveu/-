# `背包问题`


### 题目描述 [P148](https://www.luogu.com.cn/problem/P1048)

辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”
如果你是辰辰，你能完成这个任务吗？

### 输入格式
第一行有 222 个整数 T（1≤T≤10001 \le T \le 10001≤T≤1000）和 M（1≤M≤1001 \le M \le 1001≤M≤100），用一个空格隔开，T 代表总共能够用来采药的时间，M 代表山洞里的草药的数目。
接下来的 M 行每行包括两个在 111 到 100100100 之间（包括 111 和 100100100）的整数，分别表示采摘某株草药的时间和这株草药的价值。
### 输出格式
输出在规定的时间内可以采到的草药的最大总价值


```python
class solution():
    def solve(self, T, M, W, V):
        """
        :param T: capacity
        :param M: nums_of_objects
        :param W: weight
        :param V: value
        :return:
        """
        max_i_c = [[0]*(T+1) for i in range(M+1)]

        for i in range(1,M+1):
            w_i = W[i-1]
            v_i = V[i-1]
            for c in range(T+1):
                if c < w_i:
                    max_i_c[i][c] = max_i_c[i-1][c]
                else:
                    # 硬要放自己进去
                    cur_v = v_i+max_i_c[i-1][c-w_i]

                    max_i_c[i][c] = max(cur_v,max_i_c[i-1][c])
        # print(max_i_c)
        return max_i_c[-1][-1]

#优化 只需保存一个pre 一个cur 注意写法

class solution():
    def solve(self, T, M, W, V):
        """
        :param T: capacity
        :param M: nums_of_objects
        :param W: weight
        :param V: value
        :return:
        """
        pre = [0]*(T+1) 

        for i in range(1,M+1):
            cur = [0]*(T+1) 
            w_i = W[i-1]
            v_i = V[i-1]
            for c in range(T+1):
                cur[c] = pre[c]
                if w_i <= c:
                    # 硬要放自己进去
                    cur[c] = max(cur[c],v_i+cur[c-w_i])
        # print(max_i_c)
        return max_i_c[-1][-1]

if __name__ == '__main__':

    input1 = list(map(int,input().strip().split()))
    T,M = input1[0],input1[1]
    W = []
    V = []
    for i in range(M):
        input2 = list(map(int, input().strip().split()))
        W.append(input2[0])
        V.append(input2[1])
    # print(W)
    # print(V)
    print(solution().solve(T, M, W, V))


```

### 分析
网上背包问题解析很多不过大多晦涩难懂，这种是最简单的一类。
首先给出条件 
#### 条件
背包容量 capacity
总共人数 nums_of_objects
相应重量 weight
相应价值 value
#### 目标
装到最大的价值的物品

如果我们不考虑容量，
1）一个都装不下， 则无价值

2）只能装一个，且每个物品重量都一样，直接盲选价值最大的

3）全装，肯定最大（事实不可能）

上面都是极端情况，但解题思路基本就是按这几条
因为这里有两个变量（背包容量，人数），
我们定义一个
```python
max_i_c[i][c]
```
代表可以选择前i个物品时，且容量为c的时候放入物品的最大价值。

i 当我们只能选择第一个物品时，那能放进去就是价值最大。

ii 当我们可以选择两个时，设第一个重量为W1,第二个重量w2，当前容量为c。当c容量只能放一个，那选那个就行了，当c够放两个，则全放就行如 1）。关键在于只能放一个，不能放两个，那我们要选价值大的。

iii 推广到第i个（i>2)。这时我们不只是比较上一个，但好在我们可以通过迭代，知道在i-1，c的情况下最大的价值，这时我们把问题转变为该不该放下第i个物品（假设放得下的情况）。
那么考虑硬要放下时 价值为 ```python cur_v = v_i+max_i_c[i-1][c-w_i]```意思是i的价值和占了wi空间，且只能选择i-1个时的总价值，
这个值和不放时的价值比较 ```python max_i_c[i-1][c]```。

这时数组的最后一个值就是我们的答案。注意的是为了编程的方便，我们会初始化一个T+1 * M+1 数组

#### 算法复杂度
如果采取穷举，列举每件物品选择不选的可能性，选最大的 2^n

上述方法 n*w

### 题目描述 [剩余背包大小](https://www.luogu.com.cn/problem/P1049)

### 输入格式
1个整数，表示箱子容量

1个整数，表示有n个物品

接下来n行，分别表示这n个物品的各自体积

### 输出格式
1个整数，表示箱子剩余空间。

```python
C = int(input())
n = int(input())
W = []
for i in range(n):
    W.append(int(input()))

left_i_c = [[i for i in range(C+1)] for i in range(n+1)]
for i in range(1,n+1):
    W_i = W[i-1]
    for c in range(1,C+1):
        # 先跟之前一样，如果放得进再比较
        left_i_c[i][c] = left_i_c[i - 1][c]
        if W_i <= c:
            # print(i-1,c-W_i)
            cur_left = left_i_c[i-1][c-W_i]
            left_i_c[i][c] = min(cur_left,left_i_c[i-1][c])

print(left_i_c[-1][-1])

```


### 题目描述 [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

### 输入格式
给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

### 输出格式
True False

### 思路
能不能达到某个值，背包容量就是一半的nums和，因为有一半则另一半对应
如果自己就是True，不是看看不加自己或者之前的值加上自己
背包问题的核心是加或不加的情况都考虑了。

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        all_sum = sum(nums)
        N = len(nums)

        half = all_sum//2
        # C
        
        if all_sum%2 == 1 or N == 1:
            return False

        pre = [False]*(half+1)
        for i in range(N):
            cur = [False]*(half+1) 
            cur_v = nums[i]      
            for c in range(1,half+1):
                if cur_v == c:
                    cur[c] = True
                else:
                    cur[c] = pre[c] or pre[c-cur_v]
            pre = cur
            # print(i,cur_v,cur)
        return cur[-1]



```

### 题目描述 [网易笔试]
### 输入格式
给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。如果不能，则删掉一些元素，使得删掉元素的和最小

### 输出格式
删掉元素和

### 思路
上题的变形，达到某个元素的就

```python
class Solution(object):
    def canPartition(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        all_sum, N = sum(nums), len(nums)

        half = all_sum // 2
        #到总数的一半就ok，一半就是它的背包
        pre = [False]*(half+1)
        for i in range(N):
            cur = [False]*(half+1) 
            cur_v = nums[i]      
            for c in range(1,half+1):
                if cur_v == c:
                    cur[c] = True
                else:
                    cur[c] = pre[c] or pre[c-cur_v]
            pre = cur
            if i == N-1 and cur[c] == True:
                ans = all_sum - 2*c
                # 最后一行，最后一个True，就是答案。
            

        return ans

```

### 题目描述 [点菜](https://www.luogu.com.cn/problem/P1164)
拥有C的钱，选择数组的元素使之等于C,问共有多少种方法。
### 输入格式
第一行是两个数字，表示N和M。

第二行起N个正数（可以有相同的数字，每个数字均在100010001000以内）。

### 输出格式
可能性

### 思路
如果每种点法都要输出，我就想到用排序后的dfs。这个只要可能总数，记录每种选择或不选就行，c钱的点菜数首先跟之前的一样cur[c] = pre[c]，
然后如果自己就等于这个c那cur[c]+=1,如果小于这个数，看看减去自己后能点多少种cur[c] += pre[c-nums[i]]。
PS.这题有个坑，第二行并不是一行就包括所有输出，多行。

```python3
n,C = list(map(int,input().strip().split()))
nums = []
while not len(nums) >= n:
    nums += list(map(int,input().strip().split()))
pre = [0] * (C + 1)

for i in range(n):
    cur = [0]*(C+1)
    for c in range(1,C+1):
        cur[c] = pre[c]
        if nums[i] == c:
            cur[c] += 1
        if nums[i] < c:
            cur[c] += pre[c-nums[i]]
    pre = cur
    
print(cur[-1])
```
