# `二叉树1`

### 题目描述：![二叉树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)
#### 示例 1:
```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
```
#### 示例 2:
```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身
```
### 解题思路
递归关键在于把问题分解成子问题。(其实挺难的)

i、根节点角度
如果自己为 p 或 q, 那自己就是祖先，如果None, 则返回None，即自己。

如果不是，那看左边，右边是否有p,q：
    如果左边有，右无，则变成子问题，即输入当前节点的答案跟，左节点的答案一样。

    如果左边，右边同时有，还是返回自己。

### 代码

```python3
class Solution:
    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
        if not root or root == p or root == q:
            return root
        # 下面写法可能更容易理解。
        # if root == p or root == q:
        #     return root
        # if not root: return None
        
        left_ans = self.lowestCommonAncestor(root.left,p,q)
        right_ans = self.lowestCommonAncestor(root.right,p,q)

        # 如果左边没有找到，那就是右边的结果。
        if not left_ans:
            return right_ans
        
        # 同上
        if not right_ans:
            return left_ans

        # 左边和右边都找到了，说明root就是共同祖先。
        return root
```
