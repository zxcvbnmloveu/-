
### 题目描述 [P148](https://www.luogu.com.cn/problem/P1048)

辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”
如果你是辰辰，你能完成这个任务吗？

### 输入格式
第一行有 222 个整数 TTT（1≤T≤10001 \le T \le 10001≤T≤1000）和 MMM（1≤M≤1001 \le M \le 1001≤M≤100），用一个空格隔开，TTT 代表总共能够用来采药的时间，MMM 代表山洞里的草药的数目。
接下来的 MMM 行每行包括两个在 111 到 100100100 之间（包括 111 和 100100100）的整数，分别表示采摘某株草药的时间和这株草药的价值。
### 输出格式
输出在规定的时间内可以采到的草药的最大总价值


```python
class solution():
    def solve(self, T, M, W, V):
        """
        :param T: capacity
        :param M: nums_of_objects
        :param W: weight
        :param V: value
        :return:
        """
        max_i_c = [[0]*(T+1) for i in range(M+1)]

        for i in range(1,M+1):
            w_i = W[i-1]
            v_i = V[i-1]
            for c in range(T+1):
                if c < w_i:
                    max_i_c[i][c] = max_i_c[i-1][c]
                else:
                    # 硬要放自己进去
                    cur_v = v_i+max_i_c[i-1][c-w_i]

                    max_i_c[i][c] = max(cur_v,max_i_c[i-1][c])
        # print(max_i_c)
        return max_i_c[-1][-1]



if __name__ == '__main__':

    input1 = list(map(int,input().strip().split()))
    T,M = input1[0],input1[1]
    W = []
    V = []
    for i in range(M):
        input2 = list(map(int, input().strip().split()))
        W.append(input2[0])
        V.append(input2[1])
    # print(W)
    # print(V)
    print(solution().solve(T, M, W, V))


```

### 分析
网上背包问题解析很多不过大多晦涩难懂，这种是最简单的一类。
首先给出条件 
#### 条件
背包容量 capacity
总共人数 nums_of_objects
相应重量 weight
相应价值 value
#### 目标
装到最大的价值的物品

如果我们不考虑容量，
1）一个都装不下， 则无价值
2）只能装一个，且每个物品重量都一样，直接盲选价值最大的
3）全装，肯定最大（事实不可能）

上面都是极端情况，但解题思路基本就是按这几条
因为这里有两个变量（背包容量，人数），
我们定义一个
```python
max_i_c[i][c]
```
代表可以选择前i个物品时，且容量为c的时候放入物品的最大价值。
i 当我们只能选择第一个物品时，那能放进去就是价值最大。
ii 当我们可以选择两个时，设第一个重量为W1,第二个重量w2，当前容量为c。当c容量只能放一个，那选那个就行了，当c够放两个，则全放就行如 1）。
关键在于只能放一个，不能放两个，那我们要选价值大的。
iii 推广到第i个（i>2)。这时我们不只是比较上一个，但好在我们可以通过迭代，知道在i-1，c的情况下最大的价值，这时我们把问题转变为该不该放下第i个物品（假设放得下的情况）。
那么考虑硬要放下时 价值为 ```python cur_v = v_i+max_i_c[i-1][c-w_i]```意思是i的价值和占了wi空间，且只能选择i-1个时的总价值，
这个值和不放时的价值比较 ```python max_i_c[i-1][c]```。

这时数组的最后一个值就是我们的答案。注意的是为了编程的方便，我们会初始化一个T+1 * M+1 数组

#### 算法复杂度
如果采取穷举，列举每件物品选择不选的可能性，选最大的 2^n

上述方法 n*w

